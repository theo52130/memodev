<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mémo Docker</title>
  <link rel="stylesheet" href="css/style-docker.css">
  <link rel="icon" href="assets/favicon.svg" type="image/svg+xml">
</head>
<body>
  <header>
    <div class="header-container">
      <a href="../index.html" class="back-button" title="Retour à l'accueil">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M19 12H5M12 19l-7-7 7-7"/>
        </svg>
      </a>
      <h1>Mémo Docker</h1>
    </div>
    <nav>
      <ul>
        <li class="dropdown">
          <a href="#bases">Bases</a>
          <ul class="dropdown-content">
            <li><a href="#installation">Installation</a></li>
            <li><a href="#premiers-pas">Premiers pas</a></li>
            <li><a href="#concepts-fondamentaux">Concepts fondamentaux</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#commandes">Commandes Essentielles</a>
          <ul class="dropdown-content">
            <li><a href="#gestion-images">Gestion des images</a></li>
            <li><a href="#gestion-conteneurs">Gestion des conteneurs</a></li>
            <li><a href="#inspection">Inspection et logs</a></li>
            <li><a href="#reseau">Réseau</a></li>
            <li><a href="#volumes">Volumes</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#dockerfile">Dockerfile</a>
          <ul class="dropdown-content">
            <li><a href="#structure-dockerfile">Structure d'un Dockerfile</a></li>
            <li><a href="#instructions-principales">Instructions principales</a></li>
            <li><a href="#meilleures-pratiques">Meilleures pratiques</a></li>
            <li><a href="#multi-stage">Builds multi-stage</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#compose">Docker Compose</a>
          <ul class="dropdown-content">
            <li><a href="#structure-compose">Structure d'un fichier compose</a></li>
            <li><a href="#commandes-compose">Commandes compose</a></li>
            <li><a href="#environnement">Variables d'environnement</a></li>
            <li><a href="#reseaux-compose">Réseaux et volumes</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#swarm">Docker Swarm</a>
          <ul class="dropdown-content">
            <li><a href="#swarm-init">Initialisation et configuration</a></li>
            <li><a href="#services">Services Swarm</a></li>
            <li><a href="#stacks">Stacks</a></li>
            <li><a href="#swarm-securite">Sécurité dans Swarm</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#avance">Fonctionnalités Avancées</a>
          <ul class="dropdown-content">
            <li><a href="#securite">Sécurité</a></li>
            <li><a href="#optimisation">Optimisation des images</a></li>
            <li><a href="#registry">Docker Registry</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#orchestration">Orchestration</a>
          <ul class="dropdown-content">
            <li><a href="#kubernetes">Kubernetes et Docker</a></li>
            <li><a href="#docker-swarm-cluster">Docker Swarm en cluster</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#astuces">Astuces & Bonnes Pratiques</a>
          <ul class="dropdown-content">
            <li><a href="#patterns">Design patterns</a></li>
            <li><a href="#debug">Débogage</a></li>
            <li><a href="#production">En production</a></li>
            <li><a href="#ci-cd">Docker dans CI/CD</a></li>
          </ul>
        </li>
        <li>
          <button id="toggleAll">Tout développer</button>
        </li>
      </ul>
    </nav>
  </header>

  <main>
    <section id="bases">
      <h2>Les Bases de Docker</h2>
      
      <h3 id="installation">Installation</h3>
      <details>
        <summary>Installation sur Linux (Ubuntu/Debian)</summary>
        <pre>
# Désinstaller les anciennes versions potentielles
<code>sudo apt-get remove docker docker-engine docker.io containerd runc</code>

# Mettre à jour l'index des paquets
<code>sudo apt-get update</code>

# Installer les dépendances
<code>sudo apt-get install ca-certificates curl gnupg lsb-release</code>

# Ajouter la clé GPG officielle de Docker
<code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</code>

# Ajouter le repository Docker
<code>echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null</code>

# Installer Docker Engine
<code>sudo apt-get update</code>
<code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin</code>

# Vérifier que Docker fonctionne
<code>sudo docker run hello-world</code>
        </pre>
      </details>
      
      <details>
        <summary>Installation sur MacOS</summary>
        <pre>
# Utiliser Homebrew pour installer Docker Desktop
<code>brew install --cask docker</code>

# Ou télécharger et installer Docker Desktop depuis le site officiel
<code>https://www.docker.com/products/docker-desktop</code>
        </pre>
      </details>
      
      <details>
        <summary>Installation sur Windows</summary>
        <pre>
# Télécharger Docker Desktop pour Windows
<code>https://www.docker.com/products/docker-desktop</code>

# Assurez-vous que WSL2 est installé et activé
<code>wsl --install</code>
        </pre>
      </details>
      
      <details>
        <summary>Installation sur Arch Linux / Manjaro</summary>
        <pre>
# Mettre à jour le système
<code>sudo pacman -Syu</code>

# Installer Docker
<code>sudo pacman -S docker</code>

# Démarrer le service Docker
<code>sudo systemctl start docker</code>

# Activer Docker au démarrage du système
<code>sudo systemctl enable docker</code>

# Ajouter votre utilisateur au groupe docker
<code>sudo usermod -aG docker $USER</code>

# Vérifier que Docker fonctionne
<code>docker run hello-world</code>
        </pre>
      </details>
      
      <details>
        <summary>Installation sur Kali Linux</summary>
        <pre>
# Mettre à jour le système
<code>sudo apt update && sudo apt upgrade -y</code>

# Installer Docker
<code>sudo apt install -y docker.io</code>

# Démarrer le service Docker
<code>sudo systemctl start docker</code>

# Activer Docker au démarrage du système
<code>sudo systemctl enable docker</code>

# Ajouter votre utilisateur au groupe docker
<code>sudo usermod -aG docker $USER</code>

# Appliquer les changements (déconnexion/reconnexion ou exécuter)
<code>newgrp docker</code>

# Vérifier que Docker fonctionne
<code>docker run hello-world</code>
        </pre>
      </details>
      
      <details>
        <summary>Configuration post-installation</summary>
        <pre>
# Ajouter votre utilisateur au groupe docker pour éviter d'utiliser sudo
<code>sudo usermod -aG docker $USER</code>

# Appliquer les changements (déconnexion/reconnexion ou exécuter)
<code>newgrp docker</code>

# Démarrer Docker au démarrage du système
<code>sudo systemctl enable docker</code>
        </pre>
      </details>
      
      <h3 id="premiers-pas">Premiers pas avec Docker</h3>
      <details>
        <summary>Tester votre installation</summary>
        <pre>
# Exécuter un conteneur de test
<code>docker run hello-world</code>

# Vérifier la version de Docker
<code>docker --version</code>

# Afficher des informations détaillées sur Docker
<code>docker info</code>
        </pre>
      </details>
      
      <details>
        <summary>Commandes de base</summary>
        <pre>
# Lister tous les conteneurs en cours d'exécution
<code>docker ps</code>

# Lister tous les conteneurs (y compris ceux arrêtés)
<code>docker ps -a</code>

# Lister toutes les images Docker
<code>docker images</code>

# Télécharger une image depuis Docker Hub
<code>docker pull ubuntu</code>

# Exécuter un conteneur en mode interactif
<code>docker run -it ubuntu bash</code>
        </pre>
      </details>
      
      <h3 id="concepts-fondamentaux">Concepts fondamentaux</h3>
      <details>
        <summary>Architecture Docker</summary>
        <ul>
          <li><strong>Docker Engine</strong> : Service principal qui exécute les conteneurs</li>
          <li><strong>Docker Daemon</strong> : Processus en arrière-plan qui gère les objets Docker</li>
          <li><strong>Docker Client</strong> : Interface en ligne de commande pour communiquer avec le daemon</li>
          <li><strong>Docker Registry</strong> : Service qui stocke les images Docker (par défaut : Docker Hub)</li>
        </ul>
      </details>
      
      <details>
        <summary>Conteneurs vs Machines Virtuelles</summary>
        <ul>
          <li><strong>Conteneurs</strong> : 
            <ul>
              <li>Partagent le même noyau OS que l'hôte</li>
              <li>Démarrage en quelques secondes</li>
              <li>Utilisation des ressources optimisée</li>
              <li>Taille légère (MBs)</li>
            </ul>
          </li>
          <li><strong>Machines Virtuelles</strong> :
            <ul>
              <li>Émulent un système d'exploitation complet</li>
              <li>Démarrage en minutes</li>
              <li>Consommation de ressources importante</li>
              <li>Taille lourde (GBs)</li>
            </ul>
          </li>
        </ul>
      </details>
      
      <details>
        <summary>Objets Docker principaux</summary>
        <ul>
          <li><strong>Image</strong> : Plan en lecture seule utilisé pour créer des conteneurs</li>
          <li><strong>Conteneur</strong> : Instance exécutable d'une image</li>
          <li><strong>Volume</strong> : Stockage persistant des données en dehors des conteneurs</li>
          <li><strong>Réseau</strong> : Isolation et communication entre conteneurs</li>
          <li><strong>Service</strong> : Définit comment exécuter des instances de conteneurs dans un cluster</li>
        </ul>
      </details>
    </section>
    
    <section id="commandes">
      <h2>Commandes Essentielles</h2>
      
      <h3 id="gestion-images">Gestion des images</h3>
      <details>
        <summary>Recherche et téléchargement d'images</summary>
        <pre>
# Rechercher des images sur Docker Hub
<code>docker search nginx</code>

# Télécharger une image
<code>docker pull nginx</code>

# Télécharger une version spécifique (tag)
<code>docker pull nginx:1.21</code>

# Télécharger plusieurs tags
<code>docker pull -a nginx</code>
        </pre>
      </details>
      
      <details>
        <summary>Gestion des images locales</summary>
        <pre>
# Lister les images
<code>docker images</code>

# Supprimer une image
<code>docker rmi nginx</code>

# Supprimer toutes les images non utilisées
<code>docker image prune</code>

# Supprimer toutes les images sans tag (&lt;none&gt;)
<code>docker image prune -f</code>

# Créer une image à partir d'un Dockerfile
<code>docker build -t mon-app:1.0 .</code>

# Tagger une image
<code>docker tag mon-app:1.0 mon-registry/mon-app:1.0</code>
        </pre>
      </details>
      
      <h3 id="gestion-conteneurs">Gestion des conteneurs</h3>
      <details>
        <summary>Création et démarrage</summary>
        <pre>
# Créer et démarrer un conteneur
<code>docker run nginx</code>

# Créer et démarrer en mode détaché (arrière-plan)
<code>docker run -d nginx</code>

# Nommer un conteneur
<code>docker run -d --name mon-nginx nginx</code>

# Mapper un port (hôte:conteneur)
<code>docker run -d -p 8080:80 nginx</code>

# Monter un volume
<code>docker run -d -v /chemin/hote:/chemin/conteneur nginx</code>

# Définir des variables d'environnement
<code>docker run -d -e MYSQL_ROOT_PASSWORD=secret mysql</code>
        </pre>
      </details>
      
      <details>
        <summary>Gestion du cycle de vie</summary>
        <pre>
# Arrêter un conteneur
<code>docker stop mon-nginx</code>

# Démarrer un conteneur arrêté
<code>docker start mon-nginx</code>

# Redémarrer un conteneur
<code>docker restart mon-nginx</code>

# Mettre en pause un conteneur
<code>docker pause mon-nginx</code>

# Reprendre un conteneur en pause
<code>docker unpause mon-nginx</code>

# Supprimer un conteneur arrêté
<code>docker rm mon-nginx</code>

# Supprimer un conteneur en cours d'exécution
<code>docker rm -f mon-nginx</code>

# Supprimer tous les conteneurs arrêtés
<code>docker container prune</code>
        </pre>
      </details>
      
      <h3 id="inspection">Inspection et logs</h3>
      <details>
        <summary>Inspection des conteneurs</summary>
        <pre>
# Voir les détails d'un conteneur
<code>docker inspect mon-nginx</code>

# Voir les logs d'un conteneur
<code>docker logs mon-nginx</code>

# Suivre les logs en temps réel
<code>docker logs -f mon-nginx</code>

# Voir les processus dans un conteneur
<code>docker top mon-nginx</code>

# Voir les statistiques d'utilisation des ressources
<code>docker stats</code>

# Exécuter une commande dans un conteneur en cours d'exécution
<code>docker exec -it mon-nginx bash</code>
        </pre>
      </details>
      
      <h3 id="reseau">Réseau</h3>
      <details>
        <summary>Gestion des réseaux Docker</summary>
        <pre>
# Lister les réseaux
<code>docker network ls</code>

# Créer un réseau
<code>docker network create mon-reseau</code>

# Créer un réseau avec des options spécifiques
<code>docker network create --driver bridge --subnet 192.168.0.0/24 mon-reseau</code>

# Connecter un conteneur à un réseau
<code>docker network connect mon-reseau mon-nginx</code>

# Déconnecter un conteneur d'un réseau
<code>docker network disconnect mon-reseau mon-nginx</code>

# Inspecter un réseau
<code>docker network inspect mon-reseau</code>

# Supprimer un réseau
<code>docker network rm mon-reseau</code>
        </pre>
      </details>
      
      <h3 id="volumes">Volumes</h3>
      <details>
        <summary>Gestion des volumes</summary>
        <pre>
# Créer un volume
<code>docker volume create mon-volume</code>

# Lister les volumes
<code>docker volume ls</code>

# Inspecter un volume
<code>docker volume inspect mon-volume</code>

# Utiliser un volume lors de la création d'un conteneur
<code>docker run -d -v mon-volume:/app/data nginx</code>

# Monter un répertoire de l'hôte
<code>docker run -d -v /chemin/hote:/chemin/conteneur:ro nginx</code>

# Supprimer un volume
<code>docker volume rm mon-volume</code>

# Supprimer tous les volumes non utilisés
<code>docker volume prune</code>
        </pre>
      </details>
    </section>
    
    <section id="dockerfile">
      <h2>Dockerfile</h2>
      
      <h3 id="structure-dockerfile">Structure d'un Dockerfile</h3>
      <details>
        <summary>Exemple de Dockerfile de base</summary>
        <pre>
<code># Exemple de Dockerfile pour une application Node.js
FROM node:14-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .

EXPOSE 3000

CMD ["npm", "start"]</code>
        </pre>
      </details>
      
      <h3 id="instructions-principales">Instructions principales</h3>
      <details>
        <summary>FROM - Image de base</summary>
        <pre>
<code># Utiliser une image officielle
FROM nginx:latest

# Utiliser une version spécifique (recommandé)
FROM node:14-alpine

# Utiliser une image minimale
FROM alpine:3.14

# Utiliser une image depuis un autre registre
FROM registry.example.com/my-base-image:latest</code>
        </pre>
      </details>
      
      <details>
        <summary>WORKDIR, COPY et ADD</summary>
        <pre>
<code># Définir le répertoire de travail
WORKDIR /app

# Copier un fichier
COPY index.html /app/

# Copier plusieurs fichiers
COPY package.json package-lock.json ./

# Copier tous les fichiers du répertoire courant
COPY . .

# ADD - similaire à COPY mais avec fonctionnalités supplémentaires
# Peut extraire automatiquement des archives tar
ADD archive.tar.gz /app/

# Télécharger et copier depuis une URL
ADD https://example.com/file.txt /app/</code>
        </pre>
      </details>
      
      <details>
        <summary>RUN - Exécuter des commandes</summary>
        <pre>
<code># Format shell
RUN apt-get update && apt-get install -y \
    package1 \
    package2 \
    package3 \
    && rm -rf /var/lib/apt/lists/*

# Format exec (recommandé)
RUN ["npm", "install"]

# Installer des paquets sur Alpine
RUN apk add --no-cache curl git

# Créer un utilisateur non-root
RUN adduser -D myuser</code>
        </pre>
      </details>
      
      <details>
        <summary>ENV et ARG</summary>
        <pre>
<code># Définir des variables d'environnement
ENV NODE_ENV=production
ENV PORT=3000

# Définir plusieurs variables d'environnement
ENV APP_HOME=/app \
    LOG_LEVEL=info

# Arguments de build (disponibles uniquement pendant la construction)
ARG VERSION=1.0

# Utiliser un ARG
FROM node:${VERSION}

# Combiner ARG et ENV
ARG MY_ARG=default
ENV MY_ENV=${MY_ARG}</code>
        </pre>
      </details>
      
      <details>
        <summary>EXPOSE, CMD et ENTRYPOINT</summary>
        <pre>
<code># Exposer des ports
EXPOSE 80
EXPOSE 80/tcp 443/tcp

# Commande par défaut (format shell)
CMD npm start

# Commande par défaut (format exec - recommandé)
CMD ["npm", "start"]

# ENTRYPOINT - commande principale non remplaçable
ENTRYPOINT ["nginx", "-g", "daemon off;"]

# Combinaison ENTRYPOINT et CMD
ENTRYPOINT ["node"]
CMD ["app.js"]</code>
        </pre>
      </details>
      
      <details>
        <summary>USER, VOLUME et autres</summary>
        <pre>
<code># Définir l'utilisateur pour les commandes suivantes
USER myuser

# Définir l'utilisateur par UID
USER 1000

# Déclarer des volumes
VOLUME /data

# Déclarer plusieurs volumes
VOLUME ["/data", "/logs", "/tmp"]

# HEALTHCHECK pour vérifier l'état du conteneur
HEALTHCHECK --interval=30s --timeout=3s \
  CMD curl -f http://localhost/ || exit 1

# SHELL pour changer l'interpréteur par défaut
SHELL ["/bin/bash", "-c"]

# LABEL pour ajouter des métadonnées
LABEL maintainer="dev@example.com"
LABEL version="1.0" description="Mon application web"</code>
        </pre>
      </details>
      
      <h3 id="meilleures-pratiques">Meilleures pratiques</h3>
      <details>
        <summary>Optimisation des images</summary>
        <ul>
          <li>Utiliser des images de base légères (Alpine)</li>
          <li>Combiner les commandes RUN pour réduire le nombre de couches</li>
          <li>Nettoyer les caches après installation de paquets</li>
          <li>Utiliser .dockerignore pour exclure les fichiers inutiles</li>
          <li>Préférer COPY à ADD pour les cas simples</li>
        </ul>
      </details>
      
      <details>
        <summary>Sécurité</summary>
        <ul>
          <li>Éviter d'utiliser l'utilisateur root</li>
          <li>Scanner les images pour les vulnérabilités (docker scan)</li>
          <li>Limiter les capabilities Linux</li>
          <li>Ne pas stocker de secrets dans l'image</li>
          <li>Maintenir les images à jour</li>
        </ul>
      </details>
      
      <details>
        <summary>Fichier .dockerignore</summary>
        <pre>
<code># Exemple de fichier .dockerignore

# Système
.git
.github
.vscode

# Node.js
node_modules
npm-debug.log

# Logs et données
*.log
data/

# Tests et documentation
test/
docs/
README.md

# Docker
Dockerfile
docker-compose*.yml</code>
        </pre>
      </details>
      
      <h3 id="multi-stage">Builds multi-stage</h3>
      <details>
        <summary>Exemple de build multi-stage</summary>
        <pre>
<code># Étape de build
FROM node:18 AS builder

WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Étape de production
FROM nginx:alpine

# Copier le résultat du build depuis l'étape précédente
COPY --from=builder /app/dist /usr/share/nginx/html

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]</code>
        </pre>
      </details>
      
      <details>
        <summary>Avantages du multi-stage</summary>
        <ul>
          <li>Images finales plus petites</li>
          <li>Séparation des outils de build de l'environnement d'exécution</li>
          <li>Réduction de la surface d'attaque</li>
          <li>Isolation des étapes de construction</li>
        </ul>
      </details>
    </section>
    
    <section id="compose">
      <h2>Docker Compose</h2>
      
      <h3 id="structure-compose">Structure d'un fichier compose</h3>
      <details>
        <summary>Exemple de docker-compose.yml</summary>
        <pre>
<code>version: "3.8"

services:
  webapp:
    build: ./webapp
    ports:
      - "8080:80"
    depends_on:
      - db
    environment:
      - DB_HOST=db
      - DB_NAME=myapp
      - DB_USER=user
      - DB_PASSWORD=password

  db:
    image: mysql:8.0
    volumes:
      - db-data:/var/lib/mysql
    environment:
      - MYSQL_ROOT_PASSWORD=rootpassword
      - MYSQL_DATABASE=myapp
      - MYSQL_USER=user
      - MYSQL_PASSWORD=password
    ports:
      - "3306:3306"

volumes:
  db-data:</code>
        </pre>
      </details>
      
      <details>
        <summary>Options communes des services</summary>
        <pre>
<code>version: "3.8"

services:
  example-service:
    # Spécifier une image
    image: nginx:latest
    
    # OU construire depuis un Dockerfile
    build:
      context: ./app
      dockerfile: Dockerfile.dev
      args:
        VERSION: 1.0
    
    # Redémarrage automatique
    restart: always  # no, on-failure, unless-stopped, always
    
    # Ports (HOST:CONTAINER)
    ports:
      - "8080:80"
      - "443:443"
    
    # Variables d'environnement
    environment:
      - DEBUG=1
      - API_KEY=secret
    
    # OU fichier d'environnement
    env_file:
      - .env.production
    
    # Volumes
    volumes:
      - ./data:/app/data
      - logs:/app/logs
    
    # Dépendances
    depends_on:
      - db
      - redis
    
    # Configuration réseau
    networks:
      - frontend
      - backend
    
    # Limites de ressources
    deploy:
      resources:
        limits:
          cpus: "0.5"
          memory: 512M
    
    # Healthcheck
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost"]
      interval: 30s
      timeout: 10s
      retries: 3

networks:
  frontend:
  backend:

volumes:
  logs:</code>
        </pre>
      </details>
      
      <h3 id="commandes-compose">Commandes compose</h3>
      <details>
        <summary>Commandes de base</summary>
        <pre>
# Démarrer tous les services
<code>docker-compose up</code>

# Démarrer en mode détaché (arrière-plan)
<code>docker-compose up -d</code>

# Démarrer des services spécifiques
<code>docker-compose up -d webapp db</code>

# Arrêter les services
<code>docker-compose down</code>

# Arrêter et supprimer les volumes
<code>docker-compose down -v</code>

# Afficher le statut des services
<code>docker-compose ps</code>

# Voir les logs
<code>docker-compose logs</code>

# Voir les logs en temps réel
<code>docker-compose logs -f</code>

# Voir les logs d'un service spécifique
<code>docker-compose logs -f webapp</code>
        </pre>
      </details>
      
      <details>
        <summary>Construction et mise à jour</summary>
        <pre>
# Construire ou reconstruire les services
<code>docker-compose build</code>

# Construire sans cache
<code>docker-compose build --no-cache</code>

# Construire un service spécifique
<code>docker-compose build webapp</code>

# Appliquer les modifications (en cours d'exécution)
<code>docker-compose up -d --build</code>

# Tirer les dernières images
<code>docker-compose pull</code>
        </pre>
      </details>
      
      <details>
        <summary>Exécuter des commandes</summary>
        <pre>
# Exécuter une commande dans un service
<code>docker-compose exec webapp ls -la</code>

# Ouvrir un shell
<code>docker-compose exec webapp bash</code>

# Exécuter une commande en tant qu'utilisateur spécifique
<code>docker-compose exec -u www-data webapp bash</code>

# Exécuter une commande unique dans un nouveau conteneur
<code>docker-compose run --rm webapp npm test</code>
        </pre>
      </details>
      
      <h3 id="environnement">Variables d'environnement</h3>
      <details>
        <summary>Utilisation des variables d'environnement</summary>
        <pre>
<code># Définition dans docker-compose.yml
services:
  webapp:
    image: myapp
    environment:
      - API_URL=https://api.example.com
      - DEBUG=${DEBUG:-false}  # Variable avec valeur par défaut
      - SECRET_KEY  # Prend la valeur de l'environnement

# Utilisation d'un fichier .env
# .env
DEBUG=true
SECRET_KEY=my_secret

# Référence aux variables d'autres services
services:
  db:
    image: postgres
    environment:
      - POSTGRES_PASSWORD=password
  
  webapp:
    image: myapp
    environment:
      - DB_HOST=db  # Nom du service
      - DB_PORT=5432</code>
        </pre>
      </details>
      
      <details>
        <summary>Fichiers d'environnement multiples</summary>
        <pre>
# Spécifier un fichier .env alternatif
<code>docker-compose --env-file .env.production up -d</code>

# Structure de projet avec plusieurs environnements
<code>.env                # Variables par défaut
.env.development       # Variables de développement
.env.production        # Variables de production

# Utilisation:
docker-compose --env-file .env.production up -d</code>
        </pre>
      </details>
      
      <h3 id="reseaux-compose">Réseaux et volumes</h3>
      <details>
        <summary>Configuration des réseaux</summary>
        <pre>
<code>version: "3.8"

services:
  webapp:
    image: nginx
    networks:
      - frontend
      - backend
  
  api:
    image: api
    networks:
      backend:
        aliases:
          - api.local
          
networks:
  frontend:
    driver: bridge
    
  backend:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16</code>
        </pre>
      </details>
      
      <details>
        <summary>Définition des volumes</summary>
        <pre>
<code>version: "3.8"

services:
  db:
    image: postgres
    volumes:
      - postgres-data:/var/lib/postgresql/data  # Volume nommé
      - ./init:/docker-entrypoint-initdb.d      # Bind mount
      - /etc/localtime:/etc/localtime:ro        # Lecture seule
  
  webapp:
    image: myapp
    volumes:
      - ./app:/app                              # Bind mount
      - logs:/app/logs                          # Volume nommé

volumes:
  postgres-data:
    driver: local                               # Pilote par défaut
    
  logs:
    driver: local
    driver_opts:
      type: none
      device: /mnt/logs
      o: bind</code>
        </pre>
      </details>
    </section>
    
    <section id="swarm">
      <h2>Docker Swarm</h2>
      
      <h3 id="swarm-init">Initialisation et configuration</h3>
      <details>
        <summary>Configuration de base du cluster</summary>
        <pre>
# Initialiser un nouveau cluster Swarm
<code>docker swarm init --advertise-addr 192.168.1.100</code>

# Rejoindre un Swarm en tant que worker
<code>docker swarm join --token TOKEN 192.168.1.100:2377</code>

# Rejoindre un Swarm en tant que manager
<code>docker swarm join --token TOKEN 192.168.1.100:2377</code>

# Lister les nœuds du Swarm
<code>docker node ls</code>

# Promouvoir un nœud worker en manager
<code>docker node promote worker-node-1</code>

# Rétrograder un nœud manager en worker
<code>docker node demote manager-node-2</code>
        </pre>
      </details>
      
      <h3 id="services">Services Swarm</h3>
      <details>
        <summary>Déploiement de services</summary>
        <pre>
# Déployer un service
<code>docker service create --name myservice --replicas 3 nginx</code>

# Mettre à jour un service
<code>docker service update --image nginx:1.21 myservice</code>

# Mettre à l'échelle un service
<code>docker service scale myservice=5</code>

# Inspecter un service
<code>docker service inspect myservice</code>

# Voir les logs d'un service
<code>docker service logs myservice</code>

# Lister les services
<code>docker service ls</code>

# Supprimer un service
<code>docker service rm myservice</code>
        </pre>
      </details>
      
      <h3 id="stacks">Stacks</h3>
      <details>
        <summary>Stacks (avec docker-compose)</summary>
        <pre>
# Déployer une stack à partir d'un fichier compose
<code>docker stack deploy -c docker-compose.yml mystack</code>

# Lister les stacks
<code>docker stack ls</code>

# Lister les services d'une stack
<code>docker stack services mystack</code>

# Voir les tâches d'une stack
<code>docker stack ps mystack</code>

# Supprimer une stack
<code>docker stack rm mystack</code>
        </pre>
      </details>
      
      <h3 id="swarm-securite">Sécurité dans Swarm</h3>
      <details>
        <summary>Gestion des secrets Swarm</summary>
        <pre>
# Créer un secret
<code>echo "my_super_secret" | docker secret create db_password -</code>

# Créer un secret à partir d'un fichier
<code>docker secret create ssl_cert /path/to/cert.pem</code>

# Lister les secrets
<code>docker secret ls</code>

# Utiliser un secret dans un service
<code>docker service create \
  --name myservice \
  --secret db_password \
  --secret source=ssl_cert,target=/etc/ssl/cert.pem \
  myimage</code>
        </pre>
      </details>
    </section>
    
    <section id="avance">
      <h2>Fonctionnalités Avancées</h2>
      
      <h3 id="securite">Sécurité</h3>
      <details>
        <summary>Bonnes pratiques de sécurité</summary>
        <pre>
# Scanner une image pour les vulnérabilités
<code>docker scan nginx:latest</code>

# Limiter les capabilities d'un conteneur
<code>docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE nginx</code>

# Exécuter un conteneur en mode lecture seule
<code>docker run --read-only nginx</code>

# Définir des limites de mémoire et CPU
<code>docker run --memory=512m --cpus=0.5 nginx</code>
        </pre>
        <ul>
          <li>Utilisez des images officielles ou vérifiées</li>
          <li>Limitez les privilèges et capabilities</li>
          <li>Maintenez vos images à jour</li>
          <li>Ne stockez pas de secrets dans les images</li>
          <li>Utilisez des utilisateurs non-root dans vos conteneurs</li>
          <li>Scannez régulièrement vos images pour les vulnérabilités</li>
        </ul>
      </details>
      
      <h3 id="optimisation">Optimisation des images</h3>
      <details>
        <summary>Techniques d'optimisation</summary>
        <pre>
# Utiliser une image de base légère
<code>FROM alpine:3.14</code>

# Combiner les commandes RUN pour réduire les couches
<code>RUN apt-get update && \
    apt-get install -y package1 package2 && \
    rm -rf /var/lib/apt/lists/*</code>
        </pre>
        <ul>
          <li>Utilisez des images de base minimalistes comme Alpine</li>
          <li>Utilisez des builds multi-stage pour réduire la taille finale</li>
          <li>Optimisez l'ordre des couches pour tirer parti du cache Docker</li>
          <li>Nettoyez les caches et fichiers temporaires dans chaque couche</li>
        </ul>
      </details>
      
      <h3 id="registry">Docker Registry</h3>
      <details>
        <summary>Déploiement d'un registry local</summary>
        <pre>
# Démarrer un registry local
<code>docker run -d -p 5000:5000 --restart=always --name registry registry:2</code>

# Tagger une image pour le registry local
<code>docker tag mon-app:1.0 localhost:5000/mon-app:1.0</code>

# Pousser l'image vers le registry
<code>docker push localhost:5000/mon-app:1.0</code>

# Tirer l'image depuis le registry
<code>docker pull localhost:5000/mon-app:1.0</code>
        </pre>
      </details>
      
      <details>
        <summary>Sécurisation du registry</summary>
        <pre>
# Créer un certificat TLS auto-signé
<code>mkdir -p certs
openssl req -newkey rsa:4096 -nodes -sha256 \
  -keyout certs/domain.key -x509 -days 365 \
  -out certs/domain.crt</code>

# Démarrer un registry avec authentification
<code>docker run -d -p 5000:5000 --restart=always --name registry \
  -v "$(pwd)"/certs:/certs \
  -v "$(pwd)"/auth:/auth \
  -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \
  -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \
  -e REGISTRY_AUTH=htpasswd \
  -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \
  -e REGISTRY_AUTH_HTPASSWD_REALM="Registry Realm" \
  registry:2</code>

# Se connecter au registry
<code>docker login myregistry.example.com:5000</code>
        </pre>
      </details>
    </section>
    
    <section id="orchestration">
      <h2>Orchestration</h2>
      
      <h3 id="kubernetes">Kubernetes et Docker</h3>
      <details>
        <summary>Configuration de base</summary>
        <pre>
# Activer Kubernetes dans Docker Desktop
# Settings > Kubernetes > Enable Kubernetes

# Vérifier que Kubernetes fonctionne
<code>kubectl version</code>

# Obtenir les informations du cluster
<code>kubectl cluster-info</code>

# Déployer une application de test
<code>kubectl create deployment hello-node --image=k8s.gcr.io/echoserver:1.4</code>

# Exposer le déploiement
<code>kubectl expose deployment hello-node --type=LoadBalancer --port=8080</code>
        </pre>
      </details>
      
      <details>
        <summary>Kubernetes et images Docker</summary>
        <pre>
# Construire une image Docker locale
<code>docker build -t myapp:v1 .</code>

# Créer un déploiement Kubernetes avec l'image
<code>kubectl create deployment myapp --image=myapp:v1</code>

# Si l'image est dans un registry privé, créer un secret
<code>kubectl create secret docker-registry regcred \
  --docker-server=<registry-server> \
  --docker-username=<username> \
  --docker-password=<password> \
  --docker-email=<email></code>

# Référencer le secret dans le pod
<code>apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
spec:
  containers:
  - name: myapp
    image: private-registry.com/myapp:v1
  imagePullSecrets:
  - name: regcred</code>
        </pre>
      </details>
      
      <h3 id="docker-swarm-cluster">Docker Swarm en cluster</h3>
      <details>
        <summary>Déploiement avancé avec Swarm</summary>
        <pre>
# Configurer un cluster multi-managers
<code>docker swarm init --advertise-addr 192.168.1.100</code>

# Ajouter des managers supplémentaires avec le token généré
<code>docker swarm join-token manager</code>

# Configurer des contraintes de placement
<code>docker service create --name frontend \
  --constraint node.role==worker \
  --constraint node.labels.type==frontend \
  nginx</code>

# Déployer une stack multi-services
<code>docker stack deploy -c stack.yml myapp</code>

# Configurer le réseau overlay entre nodes
<code>docker network create --driver overlay --attachable mynet</code>
        </pre>
      </details>
    </section>
    
    <section id="astuces">
      <h2>Astuces & Bonnes Pratiques</h2>
      
      <h3 id="patterns">Design patterns</h3>
      <details>
        <summary>Patterns de conteneurs</summary>
        <pre>
<code>version: "3.8"

services:
  app:
    image: myapp
    volumes:
      - logs:/var/log/app

  log-collector:
    image: filebeat
    volumes:
      - logs:/var/log/app:ro
    depends_on:
      - app

volumes:
  logs:</code>
        </pre>
      </details>
      
      <h3 id="debug">Débogage</h3>
      <details>
        <summary>Outils de débogage</summary>
        <pre>
# Inspecter les processus en cours d'exécution
<code>docker top container_id</code>

# Obtenir toutes les informations d'un conteneur
<code>docker inspect container_id</code>

# Voir les modifications du système de fichiers
<code>docker diff container_id</code>

# Exécuter un shell dans un conteneur
<code>docker exec -it container_id sh</code>

# Surveiller les événements Docker
<code>docker events</code>

# Vérifier la connectivité entre conteneurs
<code>docker run --rm --network container:container_id nicolaka/netshoot</code>
        </pre>
      </details>
      
      <details>
        <summary>Dépannage courant</summary>
        <pre>
# Problème : Le conteneur s'arrête immédiatement
<code># Vérifier la commande d'entrée
docker run -it --entrypoint sh image_name

# Vérifier les logs
docker logs container_id

# Exécuter en mode interactif
docker run -it --rm image_name</code>

# Problème : Espace disque insuffisant
<code># Nettoyer les ressources inutilisées
docker system prune -a --volumes</code>

# Problème : Conteneur sans accès réseau
<code># Vérifier la configuration réseau
docker inspect container_id | grep -A20 NetworkSettings

# Vérifier DNS
docker exec container_id cat /etc/resolv.conf</code>
        </pre>
      </details>
      
      <h3 id="production">En production</h3>
      <details>
        <summary>Bonnes pratiques pour la production</summary>
        <ul>
          <li>Utiliser des images officielles ou vérifiées</li>
          <li>Limiter les ressources des conteneurs</li>
          <li>Configurer des healthchecks</li>
          <li>Mettre en place une surveillance</li>
          <li>Sauvegarder les volumes</li>
          <li>Utiliser un orchestrateur (Swarm, Kubernetes)</li>
          <li>Implémenter des déploiements sans interruption</li>
        </ul>
      </details>
      
      <details>
        <summary>Configuration de healthcheck</summary>
        <pre>
<code># Dans un Dockerfile
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost/ || exit 1

# Dans un docker-compose.yml
services:
  web:
    image: nginx
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 5s</code>
        </pre>
      </details>
      
      <details>
        <summary>Limitation des ressources</summary>
        <pre>
# Limiter les ressources d'un conteneur
<code>docker run -d \
  --memory="1g" \
  --memory-swap="2g" \
  --cpus="1.5" \
  --pids-limit=100 \
  nginx</code>

# Dans docker-compose.yml
<code>services:
  web:
    image: nginx
    deploy:
      resources:
        limits:
          cpus: "1.5"
          memory: 1G</code>
        </pre>
      </details>
      
      <h3 id="ci-cd">Docker dans CI/CD</h3>
      <details>
        <summary>GitLab CI avec Docker</summary>
        <pre>
<code># Exemple de .gitlab-ci.yml
stages:
  - build
  - test
  - deploy

build:
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  script:
    - docker build -t myapp:$CI_COMMIT_SHORT_SHA .
    - docker save myapp:$CI_COMMIT_SHORT_SHA -o myapp.tar

test:
  stage: test
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  script:
    - docker load -i myapp.tar
    - docker run myapp:$CI_COMMIT_SHORT_SHA npm test

deploy:
  stage: deploy
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  script:
    - docker load -i myapp.tar
    - docker tag myapp:$CI_COMMIT_SHORT_SHA registry.example.com/myapp:$CI_COMMIT_SHORT_SHA
    - docker push registry.example.com/myapp:$CI_COMMIT_SHORT_SHA</code>
        </pre>
      </details>
      
      <details>
        <summary>GitHub Actions avec Docker</summary>
        <pre>
<code># .github/workflows/docker.yml
name: Docker CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1
      
      - name: Build and push
        uses: docker/build-push-action@v2
        with:
          context: .
          push: false
          tags: myapp:latest
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new
          
      # Test steps would follow here</code>
        </pre>
      </details>
    </section>
  </main>

  <footer>
    <p>&copy; 2023-2025 Mémo Docker. Tous droits réservés.</p>
  </footer>

  <script src="js/script-docker.js"></script>
</body>
</html>