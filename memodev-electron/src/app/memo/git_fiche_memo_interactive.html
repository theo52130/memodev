<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mémo Git</title>
  <link rel="stylesheet" href="css/style-git.css">
  <link rel="icon" href="assets/favicon.svg" type="image/svg+xml">
</head>
<body>
  <header>
    <div class="header-container">
      <a href="../index.html" class="back-button" title="Retour à l'accueil">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M19 12H5M12 19l-7-7 7-7"/>
        </svg>
      </a>
      <h1>Mémo Git</h1>
    </div>
    <nav>
      <ul>
        <li class="dropdown">
          <a href="#bases">Bases</a>
          <ul class="dropdown-content">
            <li><a href="#configuration-initiale">Configuration initiale</a></li>
            <li><a href="#creer-cloner-depot">Créer ou cloner un dépôt</a></li>
            <li><a href="#premiers-pas">Premiers pas avec Git</a></li>
            <li><a href="#concepts-fondamentaux">Concepts fondamentaux</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#quotidien">Utilisation Quotidienne</a>
          <ul class="dropdown-content">
            <li><a href="#suivi-modifications">Suivi des modifications</a></li>
            <li><a href="#annulation-modification">Annulation et modification</a></li>
            <li><a href="#gestion-fichiers">Gestion des fichiers</a></li>
            <li><a href="#stockage-temporaire">Stockage temporaire</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#branches">Branches & Fusion</a>
          <ul class="dropdown-content">
            <li><a href="#gestion-branches">Gestion des branches</a></li>
            <li><a href="#fusion-integration">Fusion et intégration</a></li>
            <li><a href="#gestion-conflits">Gestion des conflits</a></li>
            <li><a href="#cherry-picking">Cherry-picking et historique</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#travail-distant">Travail Distant</a>
          <ul class="dropdown-content">
            <li><a href="#configuration-depots">Configuration des dépôts distants</a></li>
            <li><a href="#synchronisation-depot">Synchronisation avec le dépôt distant</a></li>
            <li><a href="#branches-distantes">Gestion des branches distantes</a></li>
            <li><a href="#tags-versions">Tags et versions</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#github">GitHub</a>
          <ul class="dropdown-content">
            <li><a href="#github-auth">Configuration et authentification</a></li>
            <li><a href="#pull-requests">Pull Requests</a></li>
            <li><a href="#github-actions">GitHub Actions</a></li>
            <li><a href="#github-pages">GitHub Pages</a></li>
            <li><a href="#github-cli">GitHub CLI</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#gitlab">GitLab</a>
          <ul class="dropdown-content">
            <li><a href="#gitlab-auth">Configuration et authentification</a></li>
            <li><a href="#merge-requests">Merge Requests</a></li>
            <li><a href="#gitlab-cicd">GitLab CI/CD</a></li>
            <li><a href="#gitlab-pages">GitLab Pages</a></li>
            <li><a href="#gitlab-snippets">GitLab Snippets et Gists</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#avance">Fonctionnalités Avancées</a>
          <ul class="dropdown-content">
            <li><a href="#rebase-interactif">Rebase interactif</a></li>
            <li><a href="#sous-modules">Sous-modules</a></li>
            <li><a href="#hooks-git">Hooks Git</a></li>
            <li><a href="#git-bisect">Git bisect pour déboguer</a></li>
            <li><a href="#filtrage-historique">Filtrage de l'historique</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#astuces">Astuces & Bonnes Pratiques</a>
          <ul class="dropdown-content">
            <li><a href="#bonnes-pratiques-commits">Bonnes pratiques pour les commits</a></li>
            <li><a href="#workflow-git">Workflow Git efficace</a></li>
            <li><a href="#alias-git">Alias Git utiles</a></li>
            <li><a href="#resolution-problemes">Résolution de problèmes courants</a></li>
          </ul>
        </li>
      </ul>
    </nav>
  </header>

  <main>
    <section id="bases">
      <h2>Les Bases de Git</h2>
      
      <h3 id="configuration-initiale">Configuration initiale</h3>
      <p>Git est un système de contrôle de version distribué qui vous permet de suivre les modifications de vos fichiers au fil du temps.</p>
      <pre>
        # Configurer votre identité pour tous les dépôts
        <code>git config --global user.name "Votre Nom"</code>
        <code>git config --global user.email "votre.email@exemple.com"</code>

        # Configurer l'éditeur par défaut
        <code>git config --global core.editor "code --wait"</code>

        # Voir la configuration actuelle
        <code>git config --list</code>
      </pre>
      
      <h3 id="creer-cloner-depot">Créer ou cloner un dépôt</h3>
      <pre>
# Initialiser un nouveau dépôt Git local
<code>git init</code>

# Cloner un dépôt existant
<code>git clone https://github.com/utilisateur/depot.git</code>

# Cloner un dépôt dans un dossier spécifique
<code>git clone https://github.com/utilisateur/depot.git mon-dossier</code>
      </pre>
      
      <h3 id="premiers-pas">Premiers pas avec Git</h3>
      <pre>
# Vérifier l'état des fichiers
<code>git status</code>

# Ajouter un fichier à la zone d'index (staging)
<code>git add nom_du_fichier</code>

# Ajouter tous les fichiers modifiés
<code>git add .</code>

# Créer un commit avec un message descriptif
<code>git commit -m "Description des changements"</code>

# Afficher l'historique des commits
<code>git log</code>
      </pre>

      <h3 id="concepts-fondamentaux">Concepts fondamentaux</h3>
      <ul>
        <li><strong>Dépôt (Repository)</strong> : L'ensemble de votre projet et son historique</li>
        <li><strong>Commit</strong> : Un instantané des modifications à un moment donné</li>
        <li><strong>Zone d'index (Staging Area)</strong> : L'endroit où vous préparez les fichiers avant commit</li>
        <li><strong>HEAD</strong> : Pointeur vers le dernier commit de la branche actuelle</li>
        <li><strong>Branche</strong> : Une ligne de développement indépendante</li>
      </ul>
    </section>

    <section id="quotidien">
      <h2>Utilisation Quotidienne</h2>
      
      <h3 id="suivi-modifications">Suivi des modifications</h3>
      <pre>
# Voir les modifications non indexées
<code>git diff</code>

# Voir les modifications indexées (prêtes pour commit)
<code>git diff --staged</code>

# Afficher les modifications entre deux commits
<code>git diff commit1 commit2</code>

# Voir le détail d'un commit spécifique
<code>git show commit_id</code>
      </pre>
      
      <h3 id="annulation-modification">Annulation et modification</h3>
      <pre>
# Annuler les modifications d'un fichier non indexé
<code>git checkout -- fichier</code>

# Désindexer un fichier sans perdre les modifications
<code>git reset HEAD fichier</code>

# Modifier le dernier commit (message et/ou contenu)
<code>git commit --amend</code>

# Annuler le dernier commit mais garder les modifications
<code>git reset --soft HEAD~1</code>

# Annuler complètement le dernier commit (dangereux)
<code>git reset --hard HEAD~1</code>

# Créer un nouveau commit qui annule un commit précédent
<code>git revert commit_id</code>
      </pre>
      
      <h3 id="gestion-fichiers">Gestion des fichiers</h3>
      <pre>
# Renommer un fichier
<code>git mv ancien_nom nouveau_nom</code>

# Supprimer un fichier
<code>git rm fichier</code>

# Supprimer un fichier déjà suivi du dépôt mais pas du disque
<code>git rm --cached fichier</code>

# Ignorer des fichiers (.gitignore)
<code>echo "*.log" >> .gitignore</code>
<code>echo "dossier/" >> .gitignore</code>
      </pre>
      
      <h3 id="stockage-temporaire">Stockage temporaire</h3>
      <pre>
# Mettre de côté des modifications non commitées
<code>git stash</code>

# Lister les stashs
<code>git stash list</code>

# Appliquer le dernier stash
<code>git stash apply</code>

# Appliquer et supprimer le dernier stash
<code>git stash pop</code>

# Créer une branche à partir d'un stash
<code>git stash branch nom_branche</code>
      </pre>
    </section>

    <section id="branches">
      <h2>Branches & Fusion</h2>
      
      <h3 id="gestion-branches">Gestion des branches</h3>
      <pre>
# Lister toutes les branches
<code>git branch</code>

# Créer une nouvelle branche
<code>git branch nom_branche</code>

# Basculer sur une branche
<code>git checkout nom_branche</code>

# Créer et basculer sur une nouvelle branche en une commande
<code>git checkout -b nouvelle_branche</code>

# Renommer une branche
<code>git branch -m ancien_nom nouveau_nom</code>

# Supprimer une branche (après fusion)
<code>git branch -d nom_branche</code>

# Forcer la suppression d'une branche (attention !)
<code>git branch -D nom_branche</code>
      </pre>
      
      <h3 id="fusion-integration">Fusion et intégration</h3>
      <pre>
# Fusionner une branche dans la branche courante
<code>git merge nom_branche</code>

# Fusion avec message personnalisé
<code>git merge nom_branche -m "Message de fusion"</code>

# Annuler une fusion en cours (en cas de conflits)
<code>git merge --abort</code>

# Réappliquer des commits sur une autre base
<code>git rebase branche_base</code>

# Interrompre un rebase en cas de conflit
<code>git rebase --abort</code>

# Continuer un rebase après résolution de conflit
<code>git rebase --continue</code>
      </pre>
      
      <h3 id="gestion-conflits">Gestion des conflits</h3>
      <pre>
# Lors d'un conflit, les fichiers sont marqués avec des marqueurs
<code><<<<<<< HEAD
version de la branche courante
=======
version de la branche à fusionner
>>>>>>> nom_branche</code>

# Après résolution manuelle des conflits
<code>git add fichier_resolu</code>
<code>git commit</code>  # ou git merge --continue / git rebase --continue
      </pre>
      
      <h3 id="cherry-picking">Cherry-picking et historique</h3>
      <pre>
# Appliquer un commit spécifique sur la branche actuelle
<code>git cherry-pick commit_id</code>

# Voir l'historique graphique
<code>git log --graph --oneline --all</code>

# Voir l'historique d'une branche
<code>git log nom_branche</code>

# Voir qui a modifié chaque ligne d'un fichier
<code>git blame fichier</code>
      </pre>
    </section>

    <section id="travail-distant">
      <h2>Travail Distant</h2>
      
      <h3 id="configuration-depots">Configuration des dépôts distants</h3>
      <pre>
# Lister les dépôts distants configurés
<code>git remote -v</code>

# Ajouter un nouveau dépôt distant
<code>git remote add nom_distant URL</code>

# Modifier l'URL d'un dépôt distant
<code>git remote set-url nom_distant nouvelle_URL</code>

# Supprimer un dépôt distant
<code>git remote remove nom_distant</code>
      </pre>
      
      <h3 id="synchronisation-depot">Synchronisation avec le dépôt distant</h3>
      <pre>
# Récupérer les dernières modifications sans fusionner
<code>git fetch nom_distant</code>

# Télécharger et fusionner les modifications de la branche distante
<code>git pull nom_distant nom_branche</code>

# Télécharger avec rebase plutôt que merge (recommandé)
<code>git pull --rebase nom_distant nom_branche</code>

# Envoyer vos modifications vers le dépôt distant
<code>git push nom_distant nom_branche</code>

# Définir une branche amont pour simplifier push/pull
<code>git push -u nom_distant nom_branche</code>
      </pre>
      
      <h3 id="branches-distantes">Gestion des branches distantes</h3>
      <pre>
# Lister les branches distantes
<code>git branch -r</code>

# Lister toutes les branches (locales et distantes)
<code>git branch -a</code>

# Créer une branche locale à partir d'une branche distante
<code>git checkout -b nom_branche nom_distant/nom_branche</code>

# Supprimer une branche distante
<code>git push nom_distant --delete nom_branche</code>
      </pre>
      
      <h3 id="tags-versions">Tags et versions</h3>
      <pre>
# Créer un tag léger
<code>git tag v1.0.0</code>

# Créer un tag annoté (recommandé pour les versions)
<code>git tag -a v1.0.0 -m "Version 1.0.0"</code>

# Lister les tags
<code>git tag</code>

# Pousser un tag spécifique vers le dépôt distant
<code>git push nom_distant v1.0.0</code>

# Pousser tous les tags
<code>git push nom_distant --tags</code>

# Supprimer un tag local
<code>git tag -d v1.0.0</code>

# Supprimer un tag distant
<code>git push nom_distant --delete v1.0.0</code>
      </pre>
    </section>

    <section id="github">
      <h2>GitHub</h2>
      
      <h3 id="github-auth">Configuration et authentification</h3>
      <pre>
# Authentification par token personnel (PAT)
<code>git remote add origin https://username:token@github.com/username/repo.git</code>

# Configuration de SSH pour GitHub
# 1. Générer une clé SSH
<code>ssh-keygen -t ed25519 -C "votre.email@exemple.com"</code>

# 2. Ajouter la clé SSH à l'agent
<code>eval "$(ssh-agent -s)"</code>
<code>ssh-add ~/.ssh/id_ed25519</code>

# 3. Copier la clé publique pour l'ajouter dans GitHub
<code>cat ~/.ssh/id_ed25519.pub</code>
# Puis ajoutez cette clé dans Settings > SSH and GPG keys sur GitHub
      </pre>
      
      <h3 id="pull-requests">Pull Requests</h3>
      <p>Les Pull Requests (PR) sont le cœur de la collaboration sur GitHub, permettant de proposer des modifications et de les examiner avant fusion.</p>
      <pre>
# Workflow typique de Pull Request
# 1. Forker le dépôt sur GitHub (via l'interface web)
# 2. Cloner votre fork
<code>git clone https://github.com/votre-username/projet.git</code>

# 3. Créer une branche pour votre fonctionnalité
<code>git checkout -b feature/nouvelle-fonctionnalite</code>

# 4. Faire vos modifications, commits et push
<code>git add .</code>
<code>git commit -m "Ajouter nouvelle fonctionnalité"</code>
<code>git push origin feature/nouvelle-fonctionnalite</code>

# 5. Créer la Pull Request sur GitHub (via l'interface web)
# 6. Après approbation, la PR peut être fusionnée via l'interface GitHub
      </pre>
      
      <h3 id="github-actions">GitHub Actions</h3>
      <p>GitHub Actions permet d'automatiser des workflows comme le CI/CD directement dans votre dépôt GitHub.</p>
      <pre>
# Exemple de fichier de workflow GitHub Actions (.github/workflows/ci.yml)
<code>name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'
      - name: Install dependencies
        run: npm ci
      - name: Run tests
        run: npm test</code>
      </pre>
      
      <h3 id="github-pages">GitHub Pages</h3>
      <p>Service d'hébergement gratuit pour les sites web statiques directement depuis un dépôt GitHub.</p>
      <pre>
# Configurer GitHub Pages pour un site
# 1. Créer une branche gh-pages ou utiliser main/master
<code>git checkout -b gh-pages</code>

# 2. Ajouter votre site HTML/CSS/JS
<code>git add index.html style.css script.js</code>
<code>git commit -m "Ajouter site pour GitHub Pages"</code>

# 3. Pousser vers GitHub
<code>git push origin gh-pages</code>

# 4. Activer GitHub Pages dans les paramètres du dépôt sur GitHub
# Settings > Pages > Source > Branch: gh-pages
      </pre>
      
      <h3 id="github-cli">GitHub CLI</h3>
      <p>Outil en ligne de commande pour interagir avec GitHub directement depuis votre terminal.</p>
      <pre>
# Installation (Ubuntu)
<code>curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg</code>
<code>echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null</code>
<code>sudo apt update</code>
<code>sudo apt install gh</code>

# Authentification
<code>gh auth login</code>

# Créer un dépôt
<code>gh repo create mon-projet --public</code>

# Créer une issue
<code>gh issue create --title "Bug dans la fonction login" --body "Description du bug"</code>

# Créer une pull request
<code>gh pr create --title "Ajouter fonctionnalité X" --body "Description des changements"</code>
      </pre>
    </section>

    <section id="gitlab">
      <h2>GitLab</h2>
      
      <h3 id="gitlab-auth">Configuration et authentification</h3>
      <pre>
# Configuration de l'accès par token
<code>git remote add origin https://oauth2:YOUR_TOKEN@gitlab.com/username/repo.git</code>

# Configuration SSH pour GitLab (similaire à GitHub)
# 1. Générer une clé SSH
<code>ssh-keygen -t ed25519 -C "votre.email@exemple.com"</code>

# 2. Ajouter la clé SSH à l'agent
<code>eval "$(ssh-agent -s)"</code>
<code>ssh-add ~/.ssh/id_ed25519</code>

# 3. Copier la clé publique et l'ajouter dans GitLab
<code>cat ~/.ssh/id_ed25519.pub</code>
# Puis ajoutez cette clé dans Preferences > SSH Keys sur GitLab
      </pre>
      
      <h3 id="merge-requests">Merge Requests</h3>
      <p>Équivalent des Pull Requests sur GitLab, les Merge Requests (MR) sont utilisées pour proposer et examiner des modifications.</p>
      <pre>
# Workflow typique de Merge Request
# 1. Forker le projet sur GitLab (via l'interface web)
# 2. Cloner votre fork
<code>git clone https://gitlab.com/votre-username/projet.git</code>

# 3. Créer une branche pour votre fonctionnalité
<code>git checkout -b feature/nouvelle-fonctionnalite</code>

# 4. Faire vos modifications, commits et push
<code>git add .</code>
<code>git commit -m "Ajouter nouvelle fonctionnalité"</code>
<code>git push origin feature/nouvelle-fonctionnalite</code>

# 5. Créer la Merge Request sur GitLab (via l'interface web)
      </pre>
      
      <h3 id="gitlab-cicd">GitLab CI/CD</h3>
      <p>GitLab intègre un puissant système CI/CD configurable via un fichier .gitlab-ci.yml.</p>
      <pre>
# Exemple de fichier .gitlab-ci.yml simple
<code>stages:
  - build
  - test
  - deploy

build:
  stage: build
  script:
    - echo "Building the application..."
    - npm install
    - npm run build

test:
  stage: test
  script:
    - echo "Running tests..."
    - npm test

deploy:
  stage: deploy
  script:
    - echo "Deploying to production..."
    - rsync -avz dist/ user@server:/path/to/deployment/
  only:
    - main</code>
      </pre>
      
      <h3 id="gitlab-pages">GitLab Pages</h3>
      <p>Service d'hébergement pour les sites statiques dans GitLab, similaire à GitHub Pages.</p>
      <pre>
# Configuration GitLab Pages via .gitlab-ci.yml
<code>pages:
  stage: deploy
  script:
    - mkdir -p public
    - cp -r index.html style.css script.js public/
  artifacts:
    paths:
      - public
  only:
    - main</code>
      </pre>
      
      <h3 id="gitlab-snippets">GitLab Snippets et Gists</h3>
      <p>GitLab permet de partager des extraits de code via les Snippets.</p>
      <pre>
# Utiliser glab CLI pour GitLab (équivalent de gh pour GitHub)
# Installation
<code>go get gitlab.com/gitlab-org/cli/cmd/glab</code>

# Authentification
<code>glab auth login</code>

# Créer un snippet
<code>glab snippet create fichier.py -t "Script Python utilitaire" -d "Description du script"</code>

# Créer un issue
<code>glab issue create --title "Bug critique" --description "Description détaillée"</code>
      </pre>
    </section>

    <section id="avance">
      <h2>Fonctionnalités Avancées</h2>
      
      <h3 id="rebase-interactif">Rebase interactif</h3>
      <pre>
# Réorganiser, modifier ou fusionner les 3 derniers commits
<code>git rebase -i HEAD~3</code>

# Options disponibles en rebase interactif:
# pick = utiliser le commit
# reword = utiliser le commit mais modifier son message
# edit = utiliser le commit mais s'arrêter pour le modifier
# squash = fusionner avec le commit précédent
# fixup = comme squash mais supprimer le message de commit
# drop = supprimer le commit
      </pre>
      
      <h3 id="sous-modules">Sous-modules</h3>
      <pre>
# Ajouter un sous-module
<code>git submodule add https://github.com/utilisateur/repo.git chemin/vers/sous-module</code>

# Initialiser les sous-modules après un clone
<code>git submodule init</code>
<code>git submodule update</code>

# Cloner un dépôt avec tous ses sous-modules
<code>git clone --recurse-submodules https://github.com/utilisateur/repo.git</code>

# Mettre à jour tous les sous-modules
<code>git submodule update --remote</code>
      </pre>
      
      <h3 id="hooks-git">Hooks Git</h3>
      <p>Les hooks permettent d'exécuter des scripts à différentes étapes du processus Git.</p>
      <pre>
# Localisation des hooks
<code>.git/hooks/</code>

# Hooks courants:
# pre-commit - Exécuté avant un commit
# pre-push - Exécuté avant un push
# post-merge - Exécuté après un merge
# post-checkout - Exécuté après un checkout

# Exemple de hook pre-commit pour vérifier le code
<code>#!/bin/sh
echo "Vérification du code avant commit..."
npm run lint</code>
      </pre>
      
      <h3 id="git-bisect">Git bisect pour déboguer</h3>
      <pre>
# Démarrer la recherche de bug
<code>git bisect start</code>

# Marquer la version actuelle comme mauvaise
<code>git bisect bad</code>

# Marquer une ancienne version connue comme bonne
<code>git bisect good v1.0.0</code>

# Git vous place à mi-chemin pour tester
# Après test, marquer comme bon ou mauvais
<code>git bisect good</code>  # ou git bisect bad

# Une fois le commit problématique trouvé
<code>git bisect reset</code>
      </pre>
      
      <h3 id="filtrage-historique">Filtrage de l'historique</h3>
      <pre>
# Rechercher un terme dans les commits
<code>git log -S "terme_recherche"</code>

# Filtrer les commits par auteur
<code>git log --author="Nom Auteur"</code>

# Filtrer les commits par date
<code>git log --since="2023-01-01" --until="2023-12-31"</code>

# Voir les fichiers modifiés dans chaque commit
<code>git log --stat</code>

# Rechercher du texte dans les fichiers à un moment donné
<code>git grep "terme" commit_id</code>
      </pre>
    </section>

    <section id="astuces">
      <h2>Astuces & Bonnes Pratiques</h2>
      
      <h3 id="bonnes-pratiques-commits">Bonnes pratiques pour les commits</h3>
      <ul>
        <li><strong>Commits atomiques</strong> : Chaque commit devrait représenter une seule modification logique</li>
        <li><strong>Messages clairs</strong> : Utilisez des messages descriptifs avec un format cohérent</li>
        <li><strong>Convention</strong> : Commencer par un verbe à l'impératif (Add, Fix, Update, Refactor)</li>
        <li><strong>Taille</strong> : Première ligne de maximum 50 caractères, puis détails après une ligne vide</li>
      </ul>
      <pre>
# Bon format de message de commit
<code>git commit -m "Add user authentication feature
                
Implement login and registration forms with JWT token
authentication. Includes password reset functionality
and email verification."</code>
      </pre>
      
      <h3 id="workflow-git">Workflow Git efficace</h3>
      <ul>
        <li><strong>GitFlow</strong> : Utilise des branches principales (main/develop) et des branches spécifiques (feature/hotfix)</li>
        <li><strong>GitHub Flow</strong> : Workflow simplifié basé sur les pull requests</li>
        <li><strong>GitLab Flow</strong> : Extension de GitHub Flow avec des branches d'environnement</li>
        <li><strong>Trunk Based</strong> : Développement sur la branche principale avec déploiements fréquents</li>
      </ul>
      <pre>
# Exemple de GitFlow

# Commencer une nouvelle fonctionnalité
<code>git checkout develop</code>
<code>git checkout -b feature/nouvelle-fonctionnalité</code>

# Après développement
<code>git checkout develop</code>
<code>git merge feature/nouvelle-fonctionnalité</code>

# Préparer une version
<code>git checkout -b release/1.0.0</code>
# Corrections finales...
<code>git checkout main</code>
<code>git merge release/1.0.0</code>
<code>git tag -a v1.0.0 -m "Version 1.0.0"</code>
      </pre>
      
      <h3 id="alias-git">Alias Git utiles</h3>
      <p>Configurez des commandes raccourcies dans votre .gitconfig :</p>
      <pre>
# Dans ~/.gitconfig
<code>[alias]
    st = status
    co = checkout
    br = branch
    ci = commit
    lg = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit</code>

# Puis utilisez comme:
<code>git st</code>  # au lieu de git status
      </pre>
      
      <h3 id="resolution-problemes">Résolution de problèmes courants</h3>
      <pre>
# Récupérer des modifications après un reset --hard
<code>git reflog</code>
<code>git checkout commit_id</code>

# Nettoyer les objets inutilisés
<code>git gc</code>

# Vérifier l'intégrité du dépôt
<code>git fsck</code>

# Si un fichier est trop gros pour GitHub/GitLab
<code>git lfs install</code>
<code>git lfs track "*.psd"</code>
<code>git add .gitattributes</code>
      </pre>
    </section>
  </main>

  <footer>
    <p>&copy; 2023-2025 Mémo Git. Tous droits réservés.</p>
  </footer>

  <script src="js/script-git.js"></script>
</body>
</html>